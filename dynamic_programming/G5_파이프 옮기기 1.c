#include <stdio.h>
#include <stdlib.h>

#define SCALE	(16)

/**
17070번: 파이프 옮기기 1
DFS로도 풀 수 있겠지만, DP로 해결할 실마리가 보였다. DFS로 풀었다면 시간초과가 났을 수도 있겠다.


map: 0: 벽, 1: 빈 공간

mode:
0: 가로, 1: 세로, 2: 대각선

파이프에서 (n,n)에 가까운 쪽의 위치를 파이프 머리, 먼 쪽은 파이프 꼬리라고 정의

dp[x][y][mode]: (x,y)에 파이프 머리가 mode의 상태로 위치해있을 수 있는 경우의 수

아래와 같이 파이프를 움직일 수 있다는 점에 주목해 점화식을 유도했다.
1. (가로, 세로, 대각선)->대각선
2. (세로, 대각선)->세로
3. (가로, 대각선)->가로

1. 현재 위치(x,y)에 파이프 머리가 (대각선)으로 놓일 수 있을 경우, 그 경우의 수는 파이프의 꼬리 부분인 (x-1, y-1)에서 파이프 머리가 (가로,세로,대각선)으로 놓였을 때의 경우의 수의 합이다.
2. 현재 위치(x,y)에 파이프 머리가 (세로)로 놓일 수 있을 경우, 그 경우의 수는 파이프의 꼬리 부분인 (x, y-1)에서 파이프 머리가 (세로,대각선)으로 놓였을 때의 경우의 수의 합이다.
3. 현재 위치(x,y)에 파이프 머리가 (가로)로 놓일 수 있을 경우, 그 경우의 수는 파이프의 꼬리 부분인 (x-1, y)에서 파이프 머리가 (가로,대각선)으로 놓였을 때의 경우의 수의 합이다.
*/

int map[SCALE+1][SCALE+1];
int dp[SCALE+1][SCALE+1][3];
int n;

int main(void) {
	scanf("%d", &n);
	for(int y = 1; y<=n; y++) {
		for(int x = 1; x<=n; x++) {
			scanf("%d", map[x]+y);
			map[x][y] = !map[x][y];
		}
	}
	dp[2][1][0] = 1;
	int x = 3;
	for(int y = 1; y<=n; y++) {
		do {
			if(!map[x][y]) continue;
			int flag = 0;
			if(map[x-1][y]) {
				flag++;
				dp[x][y][0] += dp[x-1][y][0] + dp[x-1][y][2];
			}
			if(map[x][y-1]) {
				flag++;
				dp[x][y][1] += dp[x][y-1][1] + dp[x][y-1][2];
			}
			if(flag == 2) {
				dp[x][y][2] += dp[x-1][y-1][0] + dp[x-1][y-1][1] + dp[x-1][y-1][2];
			}
		} while(++x<=n);
		x = 1;
	}
	int *v = dp[n][n];
	printf("%d", v[0]+v[1]+v[2]);
}
